<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Collection</title>
	<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="menu-container">
    <div class="menu-header">
        <h2 class="menu-title">GAME COLLECTION</h2>
        <input type="text" id="searchInput" placeholder="Search games...">
    </div>
    <!-- Added filter controls -->
    <div class="filter-controls">
		<div class="filter-row">
			<span class="filter-label">Sort by:</span>
			<div>
				<button id="sortAlpha" class="filter-button active" onclick="setSortMethod('alpha', document.getElementById('sortAlpha'))">A-Z</button>
				<button id="sortDate" class="filter-button" onclick="setSortMethod('date', document.getElementById('sortDate'))">Date</button>
				<button id="sortRating" class="filter-button" onclick="setSortMethod('rating', document.getElementById('sortRating'))">Rating</button>
				<button id="bulkImportBtn" class="filter-button" onclick="document.getElementById('bulkTextInput').click()">TxT</button>
			    <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importGames(this)">
				<input type="file" id="bulkTextInput" accept=".txt" style="display: none;" onchange="bulkImportTitles(this)">
			</div>
		</div>
        <div class="filter-row">
            <span class="filter-label">Finished:</span>
            <select id="finishedFilter" class="filter-select" onchange="applyFilters()">
                <option value="all">All</option>
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </select>
			<span class="filter-label">Checked:</span>
            <select id="isCheckedFilter" class="filter-select" onchange="applyFilters()">
                <option value="all">All</option>
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </select>
        </div>

        <div class="filter-row">
            <span class="filter-label">Platform:</span>
            <select id="platformFilter" class="filter-select" onchange="applyFilters()">
                <option value="all">All</option>
                <!-- Platform options will be populated by JavaScript -->
            </select>
        </div>
    </div>
    <div class="menu" id="menu">
        <!-- Games will be populated by JavaScript -->
    </div>
    <div class="add-entry">
        <button id="newEntryBtn" onclick="window.location.href='new-game.html'">ADD GAME</button>
        <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importGames(this)">
    </div>
</div>

<div class="description-container" id="descriptionContainer">
    <div class="no-selection">Select a game to view details</div>
</div>

<script>
    const { ipcRenderer } = require('electron');
    let games = [];
    let filteredGames = [];
    let selectedIndex = -1;
    let selectedId = -1;
    let currentSortMethod = 'alpha';
    let uniquePlatforms = new Set();

    async function loadGames() {
        try {
            const response = await fetch('http://localhost:3000/games/list');
            const newGames = await response.json();
            
            // Only update if the data has actually changed
            if (JSON.stringify(games) !== JSON.stringify(newGames)) {
                games = newGames;
                populatePlatformOptions();
                // Preserve current filters and selection when refreshing
                applyFilters();
            }
        } catch (error) {
            console.error('Error loading games:', error);
        }
    }

    function updateSelection(index, id) {
        selectedIndex = index;
        selectedId = id;
        const items = document.querySelectorAll('.menu-item');
        
        if (index >= 0 && index < filteredGames.length) {
            const game = filteredGames[index];
            
            items.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('selected');
                    
                    // Generate stars for rage rating
                    let stars = '';
                    for (let i = 0; i < 3; i++) {
                        stars += i < game.rageRating ? '★' : '☆';
                    }

                    // Generate strikes
                    let strikes = '';
                    let strikeCount = game.strikes || 0;
                    strikeCount = Math.max(0, Math.min(3, strikeCount));
                    
                    for (let i = 0; i < strikeCount; i++) {
                        strikes += 'X';
                        if (i < strikeCount - 1) {
                            strikes += ' ';
                        }
                    }

                    // Media container HTML
                    let mediaContainerHtml = '<div class="media-container">';

                    // Cover art
                    if (game.coverArtPath) {
                        mediaContainerHtml += `
                            <div class="media-item">
                                <img src="${game.coverArtPath}" onerror="this.parentNode.innerHTML='<div class=\\'no-image\\'>No Cover Art</div>'">
                            </div>`;
                    } else {
                        mediaContainerHtml += `
                            <div class="media-item">
                                <div class="no-image">No Cover Art</div>
                            </div>`;
                    }

                    // Gameplay photo
                    if (game.gameplayImagePath) {
                        mediaContainerHtml += `
                            <div class="media-item">
                                <img src="${game.gameplayImagePath}" onerror="this.parentNode.innerHTML='<div class=\\'no-image\\'>No Gameplay Image</div>'">
                            </div>`;
                    } else {
                        mediaContainerHtml += `
                            <div class="media-item">
                                <div class="no-image">No Gameplay Image</div>
                            </div>`;
                    }

                    mediaContainerHtml += '</div>';

                    // Update the description container
                    document.getElementById('descriptionContainer').innerHTML = `
                        ${mediaContainerHtml}
                        <div class="game-header">
                            <h2 class="game-title">${game.title}</h2>
                            <div class="game-date">Added: ${new Date(game.dateAdded).toLocaleDateString()}</div>
                        </div>

                        <div class="game-detail">
                            <span class="game-detail-label">Link:</span>
                            <a href="${game.link}" class="game-link" target="_blank">${game.link || 'N/A'}</a>
                        </div>

                        <div class="game-detail">
                            <span class="game-detail-label">Rage Rating:</span>
                            <span class="rating-stars">${stars}</span>
                        </div>

                        <div class="game-detail">
                            <span class="game-detail-label">Finished:</span>
                            <span class="finished-status ${game.finished ? 'finished-yes' : 'finished-no'}">
                                ${game.finished ? 'Yes' : 'No'}
                            </span>
                        </div>
						
						<div class="game-detail">
                            <span class="game-detail-label">Checked:</span>
                            <span class="is_checked-status ${game.is_checked ? 'is_checked-yes' : 'is_checked-no'}">
                                ${game.is_checked ? 'Yes' : 'No'}
                            </span>
                        </div>
						
                        <div class="game-detail">
                            <span class="game-detail-label">Platform:</span>
                            <span class="platform-tag">${game.platform || 'Not specified'}</span>
                        </div>

                        <div class="game-detail">
                            <span class="game-detail-label">Three Strikes:</span>
                            <span class="strikes">${strikes}</span>
                            <small style="margin-left: 8px; color: #777;">(${strikeCount}/3)</small>
                        </div>

                        ${game.notes ? `
                        <div class="game-notes">
                            <strong>Notes:</strong><br>
                            ${game.notes}
                        </div>
                        ` : ''}
						
						<div class="additional-content">
							${renderAdditionalContent(game)}
						</div>

                        <div class="entry-actions">
							<button class="save-btn" onclick="saveGameFiles(${game.id})">Save</button>
                            <button class="edit-btn" onclick="editGame(${game.id})">Edit</button>
                            <button class="delete-btn" onclick="deleteGame(${game.id})">Delete</button>
                            <button class="add-photo-btn" onclick="addPhoto(${game.id})">Add Photo</button>
                            <button class="add-note-btn" onclick="addNote(${game.id})">Add Note</button>
                        </div>
                    `;

                    // Add click handlers for images
                    setTimeout(() => {
                        const mediaItems = document.querySelectorAll('.media-item');
                        mediaItems.forEach(item => {
                            item.addEventListener('click', function() {
                                if (this.classList.contains('media-fullsize')) {
                                    this.classList.remove('media-fullsize');
                                } else {
                                    mediaItems.forEach(i => i.classList.remove('media-fullsize'));
                                    this.classList.add('media-fullsize');
                                }
                            });
                        });
                    }, 100);

                    // Scroll menu into view if needed
                    const menuContainer = document.querySelector('.menu');
                    if (item) {
                        const itemTop = item.offsetTop;
                        const itemBottom = itemTop + item.offsetHeight;
                        const containerScrollTop = menuContainer.scrollTop;
                        const containerBottom = containerScrollTop + menuContainer.offsetHeight;

                        if (itemTop < containerScrollTop) {
                            menuContainer.scrollTop = itemTop;
                        } else if (itemBottom > containerBottom) {
                            menuContainer.scrollTop = itemBottom - menuContainer.offsetHeight;
                        }
                    }
                } else {
                    item.classList.remove('selected');
                }
            });
        }
    }

    function editGame(id) {
        window.location.href = `edit-game.html?id=${id}`;
    }

    async function deleteGame(id) {
        if (confirm('Are you sure you want to delete this game?')) {
            try {
                const response = await fetch(`http://localhost:3000/games/delete/${id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    await loadGames();
                    if (filteredGames.length > 0) {
                        updateSelection(0, filteredGames[0].id);
                    } else {
                        document.getElementById('descriptionContainer').innerHTML = 
                            '<div class="no-selection">No games to display</div>';
                    }
                } else {
                    const error = await response.json();
                    alert('Error deleting game: ' + error.error);
                }
            } catch (error) {
                console.error('Error deleting game:', error);
                alert('Error deleting game: ' + error.message);
            }
        }
    }
	
	    function renderAdditionalContent(game) {
        let html = '';
        
        // Additional photos
        if (game.additionalPhotos && game.additionalPhotos.length > 0) {
            html += '<div class="additional-photos">';
            html += '<strong>Additional Photos:</strong><br>';
            html += '<div class="photo-gallery">';
            game.additionalPhotos.forEach((photo, index) => {
                html += `
                    <div class="photo-item">
                        <img src="${photo.path}" alt="Additional photo ${index + 1}" 
                             onclick="togglePhotoSize(this)">
                        <button class="delete-photo-btn" 
                                onclick="deletePhoto(${game.id}, ${index})">×</button>
                    </div>
                `;
            });
            html += '</div></div>';
        }
        
        // Additional notes
        if (game.additionalNotes && game.additionalNotes.length > 0) {
            html += '<div class="additional-notes">';
            html += '<strong>Additional Notes:</strong>';
            game.additionalNotes.forEach((note, index) => {
                html += `
                    <div class="note-item">
                        <div class="note-content">${note.content}</div>
                        <div class="note-date">${new Date(note.dateAdded).toLocaleDateString()}</div>
                        <button class="delete-note-btn" 
                                onclick="deleteNote(${game.id}, ${index})">×</button>
                    </div>
                `;
            });
            html += '</div>';
        }
        
        return html;
    }

    async function addPhoto(gameId) {
        console.log('Adding photo for game:', gameId);
        
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log('File selected:', file.name, 'Size:', file.size);
            
            try {
                const formData = new FormData();
                formData.append('photo', file);
                
                console.log('Sending request to:', `http://localhost:3000/games/${gameId}/add-photo`);
                
                const response = await fetch(`http://localhost:3000/games/${gameId}/add-photo`, {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Photo added successfully:', result);
                    await loadGames();
                    
                    // Refresh the current selection
                    const currentGame = filteredGames.find(g => g.id === gameId);
                    if (currentGame) {
                        const index = filteredGames.indexOf(currentGame);
                        updateSelection(index, gameId);
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Server returned error:', errorText);
                    let errorMessage = `HTTP error! status: ${response.status}`;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }
            } catch (error) {
                console.error('Error adding photo:', error);
                alert('Error adding photo: ' + error.message);
            }
        };
        input.click();
    }

    async function deletePhoto(gameId, photoIndex) {
        if (!confirm('Are you sure you want to delete this photo?')) return;
        
        try {
            const response = await fetch(`http://localhost:3000/games/${gameId}/delete-photo/${photoIndex}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                await loadGames();
                // Refresh the current selection
                const currentGame = filteredGames.find(g => g.id === gameId);
                if (currentGame) {
                    const index = filteredGames.indexOf(currentGame);
                    updateSelection(index, gameId);
                }
            } else {
                const error = await response.json();
                alert('Error deleting photo: ' + error.error);
            }
        } catch (error) {
            console.error('Error deleting photo:', error);
            alert('Error deleting photo: ' + error.message);
        }
    }

    async function addNote(gameId) {
        const noteContent = prompt('Enter your note:');
        if (!noteContent || noteContent.trim() === '') return;
        
        try {
            const response = await fetch(`http://localhost:3000/games/${gameId}/add-note`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: noteContent.trim()
                })
            });
            
            if (response.ok) {
                await loadGames();
                // Refresh the current selection
                const currentGame = filteredGames.find(g => g.id === gameId);
                if (currentGame) {
                    const index = filteredGames.indexOf(currentGame);
                    updateSelection(index, gameId);
                }
            } else {
                const error = await response.json();
                alert('Error adding note: ' + error.error);
            }
        } catch (error) {
            console.error('Error adding note:', error);
            alert('Error adding note: ' + error.message);
        }
    }

    async function deleteNote(gameId, noteIndex) {
        if (!confirm('Are you sure you want to delete this note?')) return;
        
        try {
            const response = await fetch(`http://localhost:3000/games/${gameId}/delete-note/${noteIndex}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                await loadGames();
                // Refresh the current selection
                const currentGame = filteredGames.find(g => g.id === gameId);
                if (currentGame) {
                    const index = filteredGames.indexOf(currentGame);
                    updateSelection(index, gameId);
                }
            } else {
                const error = await response.json();
                alert('Error deleting note: ' + error.error);
            }
        } catch (error) {
            console.error('Error deleting note:', error);
            alert('Error deleting note: ' + error.message);
        }
    }

    function togglePhotoSize(img) {
        img.classList.toggle('photo-fullsize');
    }

    async function exportGames() {
        try {
            const response = await fetch('http://localhost:3000/games/export');
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'game_collection_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            } else {
                const error = await response.text();
                alert('Export failed: ' + error);
            }
        } catch (error) {
            console.error('Export error:', error);
            alert('Export failed: ' + error.message);
        }
    }
		
	async function bulkImportTitles(input) {
		const file = input.files[0];
		if (!file) return;

		if (!confirm('This will create new entries for each line in the text file. Continue?')) {
			input.value = '';
			return;
		}

		try {
			const text = await file.text();
			const titles = text.split('\n')
				.map(title => title.trim())
				.filter(title => title.length > 0);

			if (titles.length === 0) {
				throw new Error('No valid titles found in the file');
			}

			const confirmation = confirm(`Found ${titles.length} titles. Create entries?`);
			if (!confirmation) {
				input.value = '';
				return;
			}

			const response = await fetch('http://localhost:3000/games/bulk-create', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ titles })
			});

			if (!response.ok) {
				const errorText = await response.text();
				try {
					// Try to parse as JSON first
					const errorData = JSON.parse(errorText);
					throw new Error(errorData.error || 'Bulk import failed');
				} catch (e) {
					// If not JSON, use the raw text
					throw new Error(errorText || 'Bulk import failed');
				}
			}

			const result = await response.json();
			alert(`Successfully created ${result.createdCount} new entries`);
			await loadGames();
		} catch (error) {
			console.error('Bulk import error:', error);
			alert('Bulk import failed: ' + error.message);
		} finally {
			input.value = '';
		}
	}

    async function importGames(input) {
        const file = input.files[0];
        if (!file) return;

        if (!confirm('Importing will replace all current games. Continue?')) {
            input.value = '';
            return;
        }

        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:3000/games/import', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Import failed');
            }

            const result = await response.json();
            alert(result.message);
            await loadGames();
        } catch (error) {
            console.error('Import error:', error);
            alert('Import failed: ' + error.message);
        } finally {
            input.value = '';
        }
    }

	function setSortMethod(method, button) {
		// Update the active button state for sort buttons only
		document.querySelectorAll('#sortAlpha, #sortDate, #sortRating').forEach(btn => {
			btn.classList.remove('active');
		});
		button.classList.add('active');
		
		// Update the current sort method
		currentSortMethod = method;
		
		// Reapply filters with new sorting
		applyFilters();
	}

    function populatePlatformOptions() {
        uniquePlatforms.clear();
        games.forEach(game => {
            if (game.platform && game.platform.trim() !== '') {
                uniquePlatforms.add(game.platform);
            }
        });

        const platformFilter = document.getElementById('platformFilter');
        const currentValue = platformFilter.value;
        
        while (platformFilter.options.length > 1) {
            platformFilter.remove(1);
        }

        uniquePlatforms.forEach(platform => {
            const option = document.createElement('option');
            option.value = platform;
            option.textContent = platform;
            platformFilter.appendChild(option);
        });

        if (Array.from(platformFilter.options).some(opt => opt.value === currentValue)) {
            platformFilter.value = currentValue;
        }
    }
	
	async function saveGameFiles(id) {
		try {
			// Get the game details
			const response = await fetch(`http://localhost:3000/games/${id}`);
			const game = await response.json();
			
			if (!game) {
				throw new Error('Game not found');
			}

			// Call the Electron function to open the folder
			const result = await ipcRenderer.invoke('open-game-folder', game.title);
			
			if (!result.success) {
				alert(result.message || 'Failed to open folder');
			}
		} catch (error) {
			console.error('Error saving game files:', error);
			alert('Error: ' + error.message);
		}
	}

	function applyFilters() {
		const searchTerm = document.getElementById('searchInput').value.toLowerCase();
		const finishedFilter = document.getElementById('finishedFilter').value;
		const isCheckedFilter = document.getElementById('isCheckedFilter').value;
		const platformFilter = document.getElementById('platformFilter').value;

		filteredGames = games.filter(game => {
			const matchesSearch = searchTerm === '' ||
				game.title.toLowerCase().includes(searchTerm) ||
				(game.platform && game.platform.toLowerCase().includes(searchTerm)) ||
				(game.notes && game.notes.toLowerCase().includes(searchTerm));

			const matchesFinished = finishedFilter === 'all' ||
				(finishedFilter === 'yes' && game.finished) ||
				(finishedFilter === 'no' && !game.finished);
				
			const matchesIsChecked = isCheckedFilter === 'all' ||
				(isCheckedFilter === 'yes' && game.is_checked) ||
				(isCheckedFilter === 'no' && !game.is_checked);

			const matchesPlatform = platformFilter === 'all' ||
				game.platform === platformFilter;

			return matchesSearch && matchesFinished && matchesPlatform && matchesIsChecked;
		});

		// Apply sorting - using slice() to create a new array
		const sortedGames = filteredGames.slice().sort((a, b) => {
			switch(currentSortMethod) {
				case 'alpha':
					return a.title.localeCompare(b.title);
				case 'date':
					return b.id - a.id;
				case 'rating':
					// Handle null/undefined ratings by treating them as 0
					const aRating = a.rageRating || 0;
					const bRating = b.rageRating || 0;
					return bRating - aRating;
				default:
					return 0;
			}
		});

		filteredGames = sortedGames;
		renderMenu();

		// Preserve selection if the currently selected game is still in filtered results
		let newSelectedIndex = -1;
		if (selectedId >= 0) {
			newSelectedIndex = filteredGames.findIndex(game => game.id === selectedId);
		}
		
		// If current selection not found, select first item
		if (newSelectedIndex === -1 && filteredGames.length > 0) {
			newSelectedIndex = 0;
		}

		selectedIndex = newSelectedIndex;
		selectedId = selectedIndex >= 0 ? filteredGames[selectedIndex].id : -1;

		if (selectedIndex >= 0) {
			updateSelection(selectedIndex, selectedId);
		} else {
			document.getElementById('descriptionContainer').innerHTML =
				'<div class="no-selection">No games match your filters</div>';
		}
	}

    function renderMenu() {
        const menu = document.getElementById('menu');
        menu.innerHTML = '';

        if (filteredGames.length === 0) {
            menu.innerHTML = '<div class="no-results">No games found</div>';
            return;
        }

        filteredGames.forEach((game, index) => {
            const menuItem = document.createElement('div');
            menuItem.className = 'menu-item' + (index === selectedIndex ? ' selected' : '');
            menuItem.onclick = () => updateSelection(index, game.id);
            menuItem.innerHTML = `
                <div><strong>${game.title}</strong></div>
            `;
            menu.appendChild(menuItem);
        });
    }

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
        loadGames();
        
        document.getElementById('searchInput').addEventListener('input', applyFilters);
        
        document.addEventListener('keydown', function(e) {
            if (filteredGames.length === 0) return;

            const oldSelectedIndex = selectedIndex;
            const descriptionContainer = document.getElementById('descriptionContainer');

			if (e.code === 'ArrowUp') {
				selectedIndex = Math.max(0, selectedIndex - 1);
				e.preventDefault();
				if (oldSelectedIndex !== selectedIndex) {
					updateSelection(selectedIndex, filteredGames[selectedIndex].id);
				}
			}
			else if (e.code === 'ArrowDown') {
				selectedIndex = Math.min(filteredGames.length - 1, selectedIndex + 1);
				e.preventDefault();
				if (oldSelectedIndex !== selectedIndex) {
					updateSelection(selectedIndex, filteredGames[selectedIndex].id);
				}
			}

            else if (e.key === 'ArrowLeft') {
                descriptionContainer.scrollBy({
                    top: -300,
                    behavior: 'smooth'
                });
                e.preventDefault();
            }
            else if (e.key === 'ArrowRight') {
                descriptionContainer.scrollBy({
                    top: 300,
                    behavior: 'smooth'
                });
                e.preventDefault();
            }
        });
    });

    // Poll for updates every 5 seconds, but preserve filters
    setInterval(loadGames, 5000);
</script>
</body>
</html>